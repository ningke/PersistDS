{"tagline":"Create large persistent data structures that also persists on disk automatically.","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Persistds","body":"Persistent Data Structures\r\n==========================\r\n\r\n# Create persistent (as in immutable) data structures that also automatically persists on permanent storage.\r\n\r\n## Introduction\r\n\r\nI was building an ngram database in the form of a Trie data structure,\r\nthe size of which, being more than 100 GB by my estimate, would not\r\nfit in the RAM of my desktop machine. This means that I have to put\r\nthe data structure on disk and only work with the part of the data\r\nstructure that can fit in memory. The solution to this problem is to\r\nbreak up the data into small chunks and make a number of small trie\r\ndata structures, marshal each trie onto disk, and finally merge all the\r\nparts. When merging, I can't unmarshal the whole trie because as parts\r\nmerge, it gets larger. Instead, I have to read only the trie nodes\r\nthat I need at the moment (along the search path) into memory and work\r\nwith those. This means I can't use Python's pickling mechanism as is\r\nsince it reads/writes the whole data structure at a time.\r\n\r\nWouldn't it be nice if I could automate the marshal/unmarshal work and\r\nwork with the data structure as I would if it fits in RAM? I wrote\r\nPersistDS to do just that - the library writes data structure to disk\r\nautomatically so it always persists (on disk), it also reads a \"node\"\r\n(e.g. that of a tree or list) of the data structure into memory when\r\nprogram needs it, all without manual intervention. With the PersistDS\r\nlibrary, a programmer can concentrate on building data structures,\r\nwithout worrying about memory constraints, no matter how big the data\r\nstructure is.\r\n\r\n## How does it work\r\n\r\nIn a normal program, an object is created in memory and the running\r\nprogram uses a reference to access that memory. In the PersistDS\r\nlibrary, an object, after being created in memory, is also written to\r\ndisk. So an object reference actually refers to a piece of storage on\r\ndisk. Since a computer program cannot directly access disk (there is\r\nno CPU instructions for loading/storing to a disk location), the\r\nobject must be read into memory whenever it is needed by the\r\nprogram. So an object reference in PersistDS indirectly refers a piece\r\nof disk storage through RAM. This object reference is called an\r\nOID. The OID is a persistent object reference - it contains a record\r\nindex (a file offset) for the object on disk, access to the persistent\r\nobject is arbitrated by the PersistDS API.\r\n\r\nIt is important to point out that a persistent object record\r\nconstructed in this fashion can contain references to other object\r\nrecords. After all, the PDS API is designed to present the storage as\r\nsome \"unlimited\" RAM to a running program. Because persistent objects\r\ncan reference each other, it is possible to constructed \"linked\" data\r\nstructures such as linked lists, trees, and graphs. Contrast this to a\r\ndatabase record, which is addressed by a key and does not usually\r\nreference another record.\r\n\r\nSome pictures to illustrate the workings of PDS:\r\n\r\nCreate an object:  Fields of an Object ==> OID\r\n<pre>\r\n--------------------------------------------------------------------------\r\n                    Memory                  |        Disk\r\n--------------------------------------------------------------------------\r\nRunning Program      |      PersistDS       |  Storage Protocol(e.g. File)\r\n--------------------------------------------------------------------------\r\ncreate object     ===|==>   Pack object  ===|==>   Write to File\r\n     ^               |                      |              |\r\n   return         &lt;==|=== Create OID     &lt;==|===   record location\r\n                     |                      |\r\n--------------------------------------------------------------------------\r\n</pre>\r\nRetrieve an object:  OID => Fields of an Object\r\n<pre>\r\n--------------------------------------------------------------------------\r\n                    Memory                  |        Disk\r\n--------------------------------------------------------------------------\r\nRunning Program      |      PersistDS       |  Storage Protocol(e.g. File)\r\n--------------------------------------------------------------------------\r\nretrieve object   ===|==> record location ==|==>   Read File\r\n  w/ OID             |                      |          |\r\n                     |                      |          V\r\n object fields    &lt;==|=== Unpack record  &lt;==|===    get record\r\n                     |                      |\r\n--------------------------------------------------------------------------\r\n</pre>\r\nPersistDS only support immutable (aka functional) data\r\nstructures. Because of this, once a persistent object is created, it\r\nwill never change, and the actual object record on disk will never\r\nchange either. This means that the object storage protocol doesn't\r\nneed to support update. Not supporting update makes it easy to\r\nallocate new space, new record can simply be appended to the\r\nend. Number of seeks are reduced as well.\r\n\r\nSo how can the PersistDS library (PDS) achieve decent performance\r\ngiven that objects are stored on disk - a medium that is not only\r\nindirectly accessible by CPU but also orders of magnitudes slower than\r\nmain memory? The answer is to use a cache, or a buffer. When an object\r\nis created, it is stored in a object cache (PDSCache) and the write\r\n(to disk) is delayed as long as there is still space in the\r\ncache. When a new object needs a cache slot and can't find any because\r\ncache is full, the least recently used (LRU) entry is flushed to the\r\nstorage. Similarly, when a program try to retrieve an object (OID\r\nread) and can't find it in the cache, the PDS library will read it\r\nfrom storage and cache the object before returning it. The PDSCache\r\ndoesn't need to be big, it should roughly match the size of the\r\n\"working set\" of the running program, i.e., the size of the current\r\nstack and global address space.\r\n\r\n## PersistDS (PDS) library API\r\n\r\n## PersistDS source code\r\n \r\n## License\r\nApache License Version 2.0\r\n","google":""}